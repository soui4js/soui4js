import { IObjRef } from "soui4/IObjRef";
import { IWindow } from "soui4/IWindow";
import { IXmlNode } from "soui4/IXml";
import { SIZE } from "soui4/Basic";
import { IStringW,IStringA } from "soui4/IString";
import { HRESULT, HSTREEITEM, UINT, int } from "soui4/Typedef";

export class ILvAdapter extends IObjRef{

    /**
     * How many items are in the data set represented by this Adapter.
     *
     * @return Count of items.
     */
    getCount():number;

    /**
     * Get a View that displays the data at the specified position in the data set. You can either
     * create a View manually or inflate it from an XML layout file. When the View is inflated, the
     * parent View (GridView, ListView...) will apply default layout parameters unless you use
     * {@link android.view.LayoutInflater#inflate(int, android.view.ViewGroup, boolean)}
     * to specify a root view and to prevent attachment to the root.
     *
     * @param position The position of the item within the adapter's data set of the item whose view
     *        we want.
     * @param pItem The old view to reuse, if possible. Note: You should check that this view
     *        is non-null and of an appropriate type before using. If it is not possible to convert
     *        this view to display the correct data, this method can create a new view.
     *        Heterogeneous lists can specify their number of view types, so that this View is
     *        always of the right type (see {@link #getViewTypeCount()} and
     *        {@link #getItemViewType(int,DWORD)}).
     * @param xmlTemplate the xml template provided by its owner
     */
    getView(position:number, pItem:IWindow, xmlTemplate:IXmlNode):void;

    /**
     * Get the type of View that will be created by {@link #getView} for the specified item.
     *
     * @param position The position of the item within the adapter's data set whose view type we
     *        want.
     * @param dwState the state of view.
     * @return An integer representing the type of View. Two views should share the same type if one
     *         can be converted to the other in {@link #getView}. Note: Integers must be in the
     *         range 0 to {@link #getViewTypeCount} - 1. {@link #IGNORE_ITEM_VIEW_TYPE} can
     *         also be returned.
     * @see #IGNORE_ITEM_VIEW_TYPE
     */
    getItemViewType(position:number, dwState:number) :number;

    /**
     * <p>
     * Returns the number of types of Views that will be created by
     * {@link #getView}. Each type represents a set of views that can be
     * converted in {@link #getView}. If the adapter always returns the same
     * type of View for all items, this method should return 1.
     * </p>
     * <p>
     * This method will only be called when when the adapter is set on the
     * the {@link AdapterView}.
     * </p>
     *
     * @return The number of types of Views that will be created by this adapter
     */
    getViewTypeCount() :number;

    /**
     * @brief 计算列表项显示大小
	 * @param [output] SIZE* ret -- 列表项大小
     * @param position int -- 列表项索引
     * @param pItem IWindow -- 列表项窗口
     * @param wid int -- 父窗口宽度
     * @param hei int -- 父窗口高度
     * @return void
     */
    getViewDesiredSize(ret:SIZE, position:number, pItem:IWindow, wid:number, hei:number):void;


    /**
     * @return true if this adapter doesn't contain any data.  This is used to determine
     * whether the empty view should be displayed.  A typical implementation will return
     * getCount() == 0 but since getCount() includes the headers and footers, specialized
     * adapters might want a different behavior.
     */
    isEmpty() :boolean;

    /**
     * @return a string object that associate with the specified item.
     */
    getItemDesc(positoin:number, pDesc:IStringW) :void;

    /**
     * init adapter from the specified template xml data
     */
    InitByTemplate( xmlTemplate:IXmlNode) :void;

	/**
     * @brief query user defined interface from adapter
     * @param REFGUID id-- __uuidof(interface)
     * @param [out] IObjRef ** ppObj -- the return interface
     * @return HRESULT S_OK--SUCCEED
     */
    QueryInterface(id:REFGUID, ppObj:IObjRef):number;
}

export class IMcAdapter extends IObjRef{
    /**
     * How many items are in the data set represented by this Adapter.
     *
     * @return Count of items.
     */
    getCount():number;

    /**
     * Get a View that displays the data at the specified position in the data set. You can either
     * create a View manually or inflate it from an XML layout file. When the View is inflated, the
     * parent View (GridView, ListView...) will apply default layout parameters unless you use
     * {@link android.view.LayoutInflater#inflate(int, android.view.ViewGroup, boolean)}
     * to specify a root view and to prevent attachment to the root.
     *
     * @param position The position of the item within the adapter's data set of the item whose view
     *        we want.
     * @param pItem The old view to reuse, if possible. Note: You should check that this view
     *        is non-null and of an appropriate type before using. If it is not possible to convert
     *        this view to display the correct data, this method can create a new view.
     *        Heterogeneous lists can specify their number of view types, so that this View is
     *        always of the right type (see {@link #getViewTypeCount()} and
     *        {@link #getItemViewType(int,DWORD)}).
     * @param xmlTemplate the xml template provided by its owner
     */
    getView(position:number, pItem:IWindow, xmlTemplate:IXmlNode):void;

    /**
     * Get the type of View that will be created by {@link #getView} for the specified item.
     *
     * @param position The position of the item within the adapter's data set whose view type we
     *        want.
     * @param dwState the state of view.
     * @return An integer representing the type of View. Two views should share the same type if one
     *         can be converted to the other in {@link #getView}. Note: Integers must be in the
     *         range 0 to {@link #getViewTypeCount} - 1. {@link #IGNORE_ITEM_VIEW_TYPE} can
     *         also be returned.
     * @see #IGNORE_ITEM_VIEW_TYPE
     */
    getItemViewType(position:number, dwState:number) :number;

    /**
     * <p>
     * Returns the number of types of Views that will be created by
     * {@link #getView}. Each type represents a set of views that can be
     * converted in {@link #getView}. If the adapter always returns the same
     * type of View for all items, this method should return 1.
     * </p>
     * <p>
     * This method will only be called when when the adapter is set on the
     * the {@link AdapterView}.
     * </p>
     *
     * @return The number of types of Views that will be created by this adapter
     */
    getViewTypeCount() :number;

    /**
     * @brief 计算列表项显示大小
	 * @param [output] SIZE* ret -- 列表项大小
     * @param position int -- 列表项索引
     * @param pItem IWindow -- 列表项窗口
     * @param wid int -- 父窗口宽度
     * @param hei int -- 父窗口高度
     * @return void
     */
    getViewDesiredSize(ret:SIZE, position:number, pItem:IWindow, wid:number, hei:number):void;


    /**
     * @return true if this adapter doesn't contain any data.  This is used to determine
     * whether the empty view should be displayed.  A typical implementation will return
     * getCount() == 0 but since getCount() includes the headers and footers, specialized
     * adapters might want a different behavior.
     */
    isEmpty() :boolean;

    /**
     * @return a string object that associate with the specified item.
     */
    getItemDesc(positoin:number, pDesc:IStringW) :void;

    /**
     * init adapter from the specified template xml data
     */
    InitByTemplate( xmlTemplate:IXmlNode) :void;

	/**
     * @brief query user defined interface from adapter
     * @param REFGUID id-- __uuidof(interface)
     * @param [out] IObjRef ** ppObj -- the return interface
     * @return HRESULT S_OK--SUCCEED
     */
    QueryInterface(id:REFGUID, ppObj:IObjRef):number;

    /**
     * @brief 获取一个列在模板中对应的窗口名称
     * @param iCol int--列索引
     * @param [out] pName IStringW--列名
     * @return void
     */
    GetColumnName(iCol:number, pName:IStringW) :void;

    //
    // int iCol: 列序号
    // remark:默认显示

    /**
     * @brief 由Adapter决定一列是否需要显示
     * @param iCol int--列序号
     * @return TRUE--显示, FALSE--隐藏
     * @remark 默认显示
     */
    IsColumnVisible(iCol:number) :boolean;

    /**
     * @brief 排序接口
     * @param iCol int--排序列
     * @param [in, out] pFmts UINT *当前列排序标志
     * @param nCols int 总列数,pFmts数组长度
     * @return TRUE--执行排序，FALSE--没有执行排序
     */
    OnSort(iCol:number, pFmts:Uint32Array, nCols:number) :boolean;
}

export class ITvAdapter extends IObjRef{

    /**
     * @brief 获取父级表项
     * @param hItem HSTREEITEM--表项索引
     * @return HSTREEITEM 父级表项
     */
    GetParentItem( hItem:HSTREEITEM )  :HSTREEITEM;

    /**
     * @brief 获取第一个子项
     * @param hItem HSTREEITEM--表项索引
     * @return HSTREEITEM--第一个子项
     */
    GetFirstChildItem( hItem:HSTREEITEM )  :HSTREEITEM;

    /**
     * @brief 获取最后一个子项
     * @param hItem HSTREEITEM--表项索引
     * @return HSTREEITEM--最后一个子项
     */
    GetLastChildItem( hItem:HSTREEITEM )  :HSTREEITEM;
 
    /**
     * @brief 获取前一个兄弟项
     * @param hItem HSTREEITEM--表项索引
     * @return HSTREEITEM--前一个兄弟项
     */
    GetPrevSiblingItem( hItem:HSTREEITEM )  :HSTREEITEM;
 
    /**
     * @brief 获取后一个兄弟项
     * @param hItem HSTREEITEM--表项索引
     * @return HSTREEITEM--后一个兄弟项
     */
    GetNextSiblingItem( hItem:HSTREEITEM )  :HSTREEITEM;

    /**
     * @brief 是否包含子项
     * @param hItem HSTREEITEM--表项索引
     * @return TRUE--有子项，FALSE--无子项
     */
    HasChildren( hItem:HSTREEITEM )  :boolean;

    /**
     * @brief 表项是否当前可见
     * @param hItem HSTREEITEM--表项索引
     * @return TRUE--可见，FALSE--不可见，被折叠
     */
    IsItemVisible( hItem:HSTREEITEM )  :boolean;

    /**
     * @brief 获取第一个可见项
     * @return HSTREEITEM--第一个可见项
     */
    GetFirstVisibleItem()  :HSTREEITEM;

    /**
     * @brief 获取最后一个可见项
     * @return HSTREEITEM--最后一个可见项
     */
    GetLastVisibleItem()  :HSTREEITEM;

	/**
     * @brief 测试一个节点是否为另一个节点的子孙节点
     * @param HSTREEITEM--hItem 父节点
	 * @param HSTREEITEM--hChild 被测试的子节点
	 * @return TRUE--是子孙节点
     */
	sDecendentItem( hItem:HSTREEITEM ,hChild:HSTREEITEM )  :boolean;

    /**
     * @brief 获取前一个可见项
     * @return HSTREEITEM--前一个可见项
     */
    GetPrevVisibleItem( hItem:HSTREEITEM )  :HSTREEITEM;

    /**
     * @brief 获取后一个可见项
     * @return HSTREEITEM--后一个可见项
     */
    GetNextVisibleItem( hItem:HSTREEITEM )  :HSTREEITEM;

    /**
     * @brief 展开/折叠子项
     * @param hItem HSTREEITEM--目标项
     * @param code  int TVC_COLLAPSE,TVC_EXPAND,TVC_TOGGLE
     * @return
     */
    ExpandItem(hItem:HSTREEITEM , code:UINT ) :void;

    /**
     * @brief 判断表项是否展开
     * @param hItem HSTREEITEM--目标项
     * @return TRUE--展开，FALSE--折叠
     */
    IsItemExpanded( hItem:HSTREEITEM )  :boolean;

    /**
     * @brief 设置表项展开标志
     * @param hItem HSTREEITEM--目标项
     * @param bExpanded TRUE--展开，FALSE--折叠
     * @return
     */
    SetItemExpanded(hItem:HSTREEITEM , bExpanded:boolean ) :void;

    /**
     * Get a View that displays the data at the specified position in the data set. You can either
     * create a View manually or inflate it from an XML layout file. When the View is inflated, the
     * parent View (GridView, ListView...) will apply default layout parameters unless you use
     * {@link android.view.LayoutInflater#inflate(int, android.view.ViewGroup, boolean)}
     * to specify a root view and to prevent attachment to the root.
     *
     * @param position The position of the item within the adapter's data set of the item whose view
     *        we want.
     * @param pItem The old view to reuse, if possible. Note: You should check that this view
     *        is non-null and of an appropriate type before using. If it is not possible to convert
     *        this view to display the correct data, this method can create a new view.
     *        Heterogeneous lists can specify their number of view types, so that this View is
     *        always of the right type (see {@link #getViewTypeCount()} and
     *        {@link #getItemViewType(int,DWORD)}).
     * @param xmlTemplate the xml template provided by its owner
     */
    getView(hItem:HSTREEITEM , pItem:IWindow, pXmlTemplate:IXmlNode) :void;

    /**
     * @brief 获取表项对应的模板ID
     * @param hItem HSTREEITEM--目标项
     * @return int--模板ID
     */
    getViewType( hItem:HSTREEITEM ) :number;

    /**
     * @brief 获取表项模板数量
     * @return int--模板数量
     */
    getViewTypeCount()  :number;

    /**
     * @brief 获取表项大小
	 * @param SIZE *ret -- 窗口大小
     * @param hItem HSTREEITEM--目标项
     * @param pItem IWindow *--窗口指针
     * @param wid int--父窗口宽度
     * @param hei int--你窗口高度
     * @return void
     */
    getViewDesiredSize(ret:LPSIZE, hItem:HSTREEITEM, pItem:IWindow, wid:int, hei:int ) :void;

    /**
     * @brief 定义行宽度和treeview客户区宽度相同
     * @return TRUE--表项宽度占满父窗口，FALSE--表项宽度和父窗口无关
     */
    isViewWidthMatchParent()  :boolean;

    /**
     * @brief init adapter from the specified template xml data
     * @param pXmlTemplate IXmlNode *--XML模板
     * @return void
     */
    InitByTemplate(pXmlTemplate:IXmlNode) :void;

    /**
     * @brief query user defined interface from adapter
     * @param REFGUID id-- __uuidof(interface)
     * @param [out] IObjRef ** ppObj -- the return interface
     * @return HRESULT S_OK--SUCCEED
     */
    QueryInterface(id:GUID, ppObj:LPPIObjRef):HRESULT;    
}